<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>21:9 Bildzuschnitt</title>
  <style>

    body { margin: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; overflow: auto; background: #f0f0f0; font-family: sans-serif; padding: 2rem; box-sizing: border-box; }
    #mainWrapper { display: flex; gap: 2rem; align-items: flex-start; }
    #workspace { display: flex; flex-direction: column; align-items: center; }
    #container { position: relative; width: 1000px; height: 428px; background: #ddd; overflow: hidden; border-radius: 8px; border: 1px solid #888; box-shadow: 0 2px 6px rgba(0,0,0,0.2); cursor: grab; }

    #container.dragging { cursor: grabbing; }
    canvas { display: block; user-select: none; pointer-events: none; }
    #placeholder { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; color: #666; font-size: 1.2rem; pointer-events: none; text-align: center; }
    #controls { margin-top: 1rem; display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; }
    button { padding: 0.5rem 1rem; border: none; border-radius: 4px; background: #007acc; color: white; font-size: 1rem; cursor: pointer; transition: background 0.2s; }
    button:hover { background: #005fa3; }
    button:disabled { background: #b0b0b0; cursor: not-allowed; }
    #fileInput { display: none; }
    #previewSection { margin-top: 1.5rem; width: 303px; max-width: 100%; display: flex; flex-direction: column; gap: 0.5rem; align-items: center; }
    #previewSection h2 { margin: 0; font-size: 1.1rem; color: #333; }
    #previewCanvas { width: 303px; height: 170px; border: 1px solid #888; border-radius: 6px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    #placeholder { flex-direction: column; gap: 0.75rem; }
    #placeholderMain { font-size: 1.2rem; }
    #placeholderHint { font-size: 0.95rem; line-height: 1.4; color: #444; max-width: 80%; }
    .rangeLabel { display: flex; align-items: center; gap: 0.5rem; font-size: 1rem; color: #333; }
    .rangeLabel input[type="range"] { width: 220px; }
    .miniBtn { padding: 0.35rem 0.6rem; font-size: 0.85rem; background: #e0e0e0; color: #333; border-radius: 4px; border: 1px solid #c0c0c0; cursor: pointer; transition: background 0.2s, color 0.2s; }
    .miniBtn:hover { background: #d0d0d0; }
    .miniBtn:active { background: #c0c0c0; }
    .miniBtn:disabled { background: #efefef; color: #9c9c9c; cursor: default; }
    #historyControls { display: flex; align-items: center; gap: 0.4rem; padding: 0.35rem 0.6rem; border: 1px solid #cfcfcf; border-radius: 4px; background: #fafafa; }
    #historyStatus { min-width: 4rem; text-align: center; font-size: 0.9rem; color: #333; }
  </style>
</head>
<body>
  <div id="mainWrapper">
    <div id="workspace">
      <div id="container" tabindex="0">
        <canvas id="canvas"></canvas>
        <div id="placeholder">
          <div id="placeholderMain">Bild hier einfügen, ablegen oder laden</div>
          <div id="placeholderHint">Bild mit der Maus verschieben. Scrollen für Zoom (für Feinzoom [Strg] gedrückt halten)</div>
        </div>
      </div>
      <div id="controls">
        <button id="loadBtn">Bild laden</button>
        <button id="saveBtn" disabled>Speichern</button>
        <button id="copyBtn" disabled>Ausschnitt kopieren</button>
        <label class="rangeLabel">Drehen:
          <input type="range" id="rotateRange" min="-45" max="45" value="0">
          <button id="resetRotation" type="button" class="miniBtn" aria-label="Rotation auf 0 Grad zurücksetzen">↺</button>
        </label>
        <div id="historyControls" aria-live="polite">
          <button id="historyPrev" type="button" class="miniBtn" aria-label="Voriges Bild anzeigen" disabled>←</button>
          <span id="historyStatus">– / –</span>
          <button id="historyNext" type="button" class="miniBtn" aria-label="Nächstes Bild anzeigen" disabled>→</button>
        </div>
      </div>
      <div id="previewSection">
        <h2>Vorschau 16:9</h2>
        <canvas id="previewCanvas" width="303" height="170"></canvas>
      </div>
    </div>
  </div>
  <input type="file" id="fileInput" accept="image/*" />

  <script>
    const container = document.getElementById('container');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const previewCanvas = document.getElementById('previewCanvas');
    const previewCtx = previewCanvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');
    const loadBtn = document.getElementById('loadBtn');
    const saveBtn = document.getElementById('saveBtn');
    const copyBtn = document.getElementById('copyBtn');
    const rotateRange = document.getElementById('rotateRange');
    const resetRotationBtn = document.getElementById('resetRotation');
    const placeholder = document.getElementById('placeholder');
    const historyPrevBtn = document.getElementById('historyPrev');
    const historyNextBtn = document.getElementById('historyNext');
    const historyStatus = document.getElementById('historyStatus');
    let img = new Image(), scale = 1, minScale = 1, offsetX = 0, offsetY = 0, rotation = 0;
    let isDragging = false, startX = 0, startY = 0, filename = '';
    let imageHistory = [];
    let historyIndex = -1;
    let activeLoadToken = 0;

    function resizeCanvas() {
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      clampOffsets();
      draw();
      if(img.naturalWidth) updateHistoryState();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function loadImageFile(file) {
      if(!file) return;
      const reader = new FileReader();
      reader.onload = e => addImageToHistory(e.target.result, file.name || 'Bild');
      reader.readAsDataURL(file);
      fileInput.value = '';
    }
    function loadImageURL(url) {
      if(!url) return;
      const nameFromUrl = url.startsWith('data:') ? 'Bild' : (url.split('/').pop() || 'Bild');
      addImageToHistory(url, nameFromUrl);
    }
    function initImage(src, name, storedState) {
      const loadToken = ++activeLoadToken;
      const targetIndex = historyIndex;
      const nextImage = new Image();
      nextImage.crossOrigin = 'anonymous';
      nextImage.onload = () => {
        if(loadToken !== activeLoadToken || targetIndex !== historyIndex) return;
        img = nextImage;
        minScale = Math.max(canvas.width/img.width, canvas.height/img.height);
        const defaultOffsetX = (canvas.width - img.width*minScale)/2;
        const defaultOffsetY = (canvas.height - img.height*minScale)/2;

        if(storedState) {
          scale = Math.max(minScale, storedState.scale || minScale);
          rotation = typeof storedState.rotation === 'number' ? storedState.rotation : 0;
          offsetX = typeof storedState.offsetX === 'number' ? storedState.offsetX : defaultOffsetX;
          offsetY = typeof storedState.offsetY === 'number' ? storedState.offsetY : defaultOffsetY;
        } else {
          scale = minScale;
          rotation = 0;
          offsetX = defaultOffsetX;
          offsetY = defaultOffsetY;
        }

        clampOffsets();
        rotateRange.value = Math.round(rotation * 180 / Math.PI);
        draw();
        saveBtn.disabled = false;
        copyBtn.disabled = false;
        placeholder.style.display = 'none';
        updateHistoryState();
        filename = (name || 'export').replace(/\.[^/.]+$/, '');
      };
      nextImage.src = src;
    }
    function clampOffsets() {
      if(!img || !img.width) return;
      const minOffsetX = canvas.width - img.width * scale;
      const minOffsetY = canvas.height - img.height * scale;
      const maxOffsetX = 0;
      const maxOffsetY = 0;
      offsetX = Math.min(maxOffsetX, Math.max(minOffsetX, offsetX));
      offsetY = Math.min(maxOffsetY, Math.max(minOffsetY, offsetY));
    }
    function captureState() {
      return { scale, offsetX, offsetY, rotation };
    }
    function updateHistoryState() {
      if(historyIndex >= 0 && imageHistory[historyIndex]) {
        imageHistory[historyIndex].state = captureState();
      }
    }
    function updateHistoryControls() {
      const hasEntries = imageHistory.length > 0;
      historyPrevBtn.disabled = !hasEntries || historyIndex <= 0;
      historyNextBtn.disabled = !hasEntries || historyIndex >= imageHistory.length - 1;
      historyStatus.textContent = hasEntries ? `${historyIndex + 1} / ${imageHistory.length}` : '– / –';
    }
    function addImageToHistory(src, name) {
      if(!src) return;
      updateHistoryState();
      if(historyIndex < imageHistory.length - 1) {
        imageHistory = imageHistory.slice(0, historyIndex + 1);
      }
      imageHistory.push({ src, name, state: null });
      historyIndex = imageHistory.length - 1;
      initImage(src, name);
      updateHistoryControls();
    }
    function navigateHistory(step) {
      if(!imageHistory.length) return;
      const newIndex = historyIndex + step;
      if(newIndex < 0 || newIndex >= imageHistory.length) return;
      updateHistoryState();
      historyIndex = newIndex;
      const entry = imageHistory[historyIndex];
      initImage(entry.src, entry.name, entry.state);
      updateHistoryControls();
    }
    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(img.src) {
        ctx.save();
        ctx.translate(offsetX + img.width*scale/2, offsetY + img.height*scale/2);
        ctx.rotate(rotation);
        ctx.drawImage(img, -img.width*scale/2, -img.height*scale/2, img.width*scale, img.height*scale);
        ctx.restore();
        placeholder.style.display = 'none';
        updatePreview();
      } else {
        placeholder.style.display = 'flex';
        clearPreview();
      }
    }

    loadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => loadImageFile(fileInput.files[0]));
    rotateRange.addEventListener('input', () => {
      rotation = parseFloat(rotateRange.value) * Math.PI / 180;
      draw();
      updateHistoryState();
    });

    resetRotationBtn.addEventListener('click', () => {
      rotateRange.value = 0;
      rotation = 0;
      draw();
      updateHistoryState();
    });

    container.addEventListener('dragover', e => { e.preventDefault(); container.classList.add('dragging'); });
    container.addEventListener('dragleave', () => container.classList.remove('dragging'));
    container.addEventListener('drop', e => {
      e.preventDefault(); container.classList.remove('dragging');
      const dt = e.dataTransfer;
      // Dateien
      if(dt.files && dt.files.length) {
        loadImageFile(dt.files[0]);
        return;
      }
      // externe URL (bild von anderem Tab)
      let url = dt.getData('text/uri-list') || dt.getData('text/plain');
      if(url && (url.match(/\.(jpe?g|png|gif|webp)(\?|$)/i))) {
        loadImageURL(url);
        return;
      }
      // HTML-Snippet
      let html = dt.getData('text/html');
      if(html) {
        const div = document.createElement('div'); div.innerHTML = html;
        const imgEl = div.querySelector('img');
        if(imgEl && imgEl.src) loadImageURL(imgEl.src);
      }
    });

    container.addEventListener('paste', e => {
      const items = e.clipboardData.items;
      for(let item of items) {
        if(item.kind==='file'&&item.type.startsWith('image/')){
          loadImageFile(item.getAsFile());return;
        }
      }
    });

    container.addEventListener('mousedown', e => {
      if(!img.src) return;
      isDragging = true; startX = e.clientX - offsetX; startY = e.clientY - offsetY;
      container.classList.add('dragging');
    });
    window.addEventListener('mousemove', e => {
      if(isDragging) {
        offsetX = e.clientX - startX; offsetY = e.clientY - startY;
        clampOffsets();
        draw();
        updateHistoryState();
      }
    });
    window.addEventListener('mouseup', () => { isDragging=false; container.classList.remove('dragging'); updateHistoryState(); });


    const handleWheel = e => {
      if(!img.src) return; e.preventDefault();
      const sensitivity = e.ctrlKey ? 0.00015 : 0.001;
      const oldScale=scale, delta=-e.deltaY*sensitivity;
      scale=Math.max(minScale, scale*(1+delta));
      const rect=container.getBoundingClientRect();
      const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      offsetX=mx-(mx-offsetX)*(scale/oldScale);
      offsetY=my-(my-offsetY)*(scale/oldScale);
      clampOffsets();
      draw();
      updateHistoryState();
    };

    container.addEventListener('wheel', handleWheel, { passive: false });

    function createOutputCanvas(){
      const exportScale = 1/scale;
      const out=document.createElement('canvas');
      out.width=Math.round(canvas.width*exportScale);
      out.height=Math.round(canvas.height*exportScale);
      const octx=out.getContext('2d');
      octx.translate(offsetX*exportScale + img.width/2, offsetY*exportScale + img.height/2);
      octx.rotate(rotation);
      octx.drawImage(img, -img.width/2, -img.height/2);
      return out;
    }

    function clearPreview(){
      previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
      previewCanvas.style.opacity = 0.4;
    }

    function updatePreview(){
      if(!img.src) {
        clearPreview();
        return;
      }

      const previewAspect = 16/9;
      let srcWidth = canvas.height * previewAspect;
      let srcHeight = canvas.height;

      if(srcWidth > canvas.width) {
        srcWidth = canvas.width;
        srcHeight = srcWidth / previewAspect;
      }

      const srcX = (canvas.width - srcWidth) / 2;
      const srcY = (canvas.height - srcHeight) / 2;

      previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
      previewCtx.drawImage(canvas, srcX, srcY, srcWidth, srcHeight, 0, 0, previewCanvas.width, previewCanvas.height);
      previewCanvas.style.opacity = 1;
    }

    saveBtn.addEventListener('click', ()=>{
      const out=createOutputCanvas();
      out.toBlob(blob=>{
        const link=document.createElement('a');
        link.download=filename+'_zuschnitt.jpg';
        link.href=URL.createObjectURL(blob); link.click(); URL.revokeObjectURL(link.href);
      },'image/jpeg');
    });

    function copyCrop(){
      if(!img.src) return;
      const out=createOutputCanvas();
      out.toBlob(async blob=>{
        try{
          await navigator.clipboard.write([new ClipboardItem({[blob.type]: blob})]);
        }catch(err){
          console.error('Clipboard copy failed', err);
        }
      },'image/png');
    }

    copyBtn.addEventListener('click', copyCrop);
    document.addEventListener('keydown', e=>{
      if(e.ctrlKey && e.key.toLowerCase()==='c'){
        e.preventDefault();
        copyCrop();
      }
    });

    historyPrevBtn.addEventListener('click', () => navigateHistory(-1));
    historyNextBtn.addEventListener('click', () => navigateHistory(1));

    updateHistoryControls();

    clearPreview();
    container.focus();
  </script>
</body>
</html>

